# Lower bound

> 찾고자 하는 값 이상이 처음 나타나는 위치.

```java
private static int lower_bound(int[] arr, int s, int e, int check) {
	int m;
	while (e - s > 0) {
		m = (s + e) / 2;
		if (arr[m] < check)
			s = m + 1;
		else
			e = m;
	}
	return e;
}
```

 

### 예시

 먼저, 데이터가 입력되어있는 배열을 A[], 찾고자 하는 값을 k, lower bound를 찾고자 하는 구간을 [s, e]로 설정하면, 구간 내의 중간 위치를 m이라고 할때, A[m-1] < k이면서 A[m] >= k를 만족하는 최소 m을 찾는 문제가 된다.

[5, 7, 9, 11, 13, 15] 에서 11을 탐색할 때, 11과 같거나 큰 수가 나오는 첫 위치가 바로 lower bound이다.

이때, m은 2이상인 값이 되는데, 일반적인 이분탐색 방법에서 A[m] == k인 부분을 포함시키면 된다.

또한, 모든 원소가 k보다 작을 때에는 n+1을 출력해야 하므로, **처음 구간을 잡을 때, [1, n]을 잡는 대신 [1, n+1]을 잡아야 한다.**


```
[5, 7, 9, 11, 13, 15]
 |        |           |
 s        m           e
```

정렬되어 있는 데이터를 입력 받은 상태에서 탐색 준비를 한다.
탐색 구간의 시작인 s=0, e=len(A)=6, 중간 위치를 3으로 계산된다.

**A[3]의 값(11)이 찾고자 하는 11보다 크거나 같기 때문에, 탐색 구간을 [0, 3]로 바꾼다.lower bound는 k이상의 값이 나타나는 최소위치이므로, 마지막 위치 (e)까지 포함 시켜야 한다.** [0,3]의 중간 위치는 (0+3)/2 = 1가 된다.


```
[5, 7, 9, 11, 13, 15]
 |  |     |
 s  m     e
```


A[1]의 값(7)이 찾고자 하는 11보다 작으므로, 탐색 구간을 [2, 3]로 바꾸고 다시 탐색해 나간다. [2, 3]의 중간 위치는 (2+3)/2=2이 된다.

```
[5, 7, 9, 11, 13, 15]
       |  |
      s,m  e
```

이제 m은 (2+3)/2=2 이 된다. 9가 11보다 작으므로 s=3으로 세팅한다

```
[5, 7, 9, 11, 13, 15]
           |  
          s,e
```

s와 e가 이 같아서 이제 범위를 줄일 수 없으므로 답은 3이 된다.





# Upper bound

> 찾고자 하는 값보다 큰 값이 처음으로 나타나는 위치

- Lower바운드는 key값을 찾지만, Upper은 key 보다 큰 것을 찾는다.

```java
private static int upper_bound(int[] arr, int s, int e, int check) {
	int m;
	while (e - s > 0) {
		m = (s + e) / 2;
		if (arr[m] <= check)
			s = m + 1;
		else
			e = m;
	}
	return e;
}
```



### 예시

먼저, 데이터가 입력되어있는 배열을 A[], 찾고자 하는 값을 k, upper bound를 찾고자 하는 구간을 [s,e]로 설정하면, 구간 내의 중간 위치를 m이라고 생각할 때, A[m-1] <= k 이면서 A[m]>k를 만족하는 최소 m을 찾는 문제가 된다.



[5, 7, 9, 11, 13, 15] 에서 11를 탐색할 때, 11을 초과하는 첫 위치가 바로 upper bound이다



이때, m은 2이상인 값이 되는데, 일반적인 이분탐색에서 A[m] == k인 부분을 포함시키면 된다. 또한, 모든 원소가 k보다 작을 때에는 n+1을 출력해야 하므로, 처음 구간을 잡을 때, [1, n]을 잡는 대신 [1, n+1]을 잡아야 한다.


```
[5, 7, 9, 11, 13, 15]
 |        |           |
 s        m           e
```

데이터를 A[] 배열에 모두 입력 받은 상태에서 탐색 준비를 한다. 찾아야할 데이터 k(7)보다 큰 가장 첫 위치 upper bound, 탐색 구간의 시작위치와 마지막 위치는 s=0, e=7+1이 되고, 중간 위치를 계산하면 (0+8)/2 = 4가 된다.
그런데 arr[3] = 11 이므로 해당 값이 11과 작거나 같기 때문에, s=m+1=4로 세팅한다.

```
[5, 7, 9, 11, 13, 15]
               |   |   |
               s   m   e
```

(4+6)/2=5, arr[5]=15로 11보다 크므로 e값을 e=m=5으로 세팅한다.

```
[5, 7, 9, 11, 13, 15]
               |   | 
              s,m  e
```

(4+5)/2=4, arr[4] = 13으로 11보다 크므로 e=m=4로 세팅한다

```
[5, 7, 9, 11, 13, 15]
               |
              s,e
```

s와 e 값이 값으므로 값을 그대로 리턴한다.



### 참고

c++의 경우에는 함수로 이미 구현되어 있다.

```c++
#include <algorithm>

lower_bound( begin(), end(), value);
upper_bound( begin(), end(), value);
```





출처 :

https://12bme.tistory.com/120