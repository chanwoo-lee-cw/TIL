# SOLID 원칙

객체 지향 프로그래밍(OOP)에서 가급적이면 지켜줘야했으면 하는 5가지 원칙의 약자
즉, 코드의 확장성과 재사용성을 높이고, 복잡도를 줄이기 위해 제안된 5가지 원칙이다.

## 단일 책임 원칙 (Single Responsibility Principle, SRP)

> **하나의 클래스(객체)는 단 하나의 책임만 가져야** 한다는 원칙

- 클래스는 언제나 하나의 기능을 가져야 하고, 가급적이면 각자 따로 나누는 것이 좋다는 원칙
- 예를 들면, 주문이 들어왔을 때 재고를 차감하는 부분과 구매자에게 메일을 보내는 부분을 분리하는게 낫다.
- 한 클래스가 다른 클래스의 기능을 지원한다면, 만약 이 클래스에 문제가 생기면 이 기능을 사용하는 다른 기능들도 문제가 생기 때문이기도 하고, 이 기능이 왜 이 클래스에 있는지 확인하기 어려워서 유지보수가 어려워진다.



## 개방 폐쇄 원칙 (Open Closed Principle, OCP)

> 클래스는 **확장에 대해 열려 있어야 하며, 수정에는 닫혀**있어야 한다는 원칙

- 기능 추가가 필요한 경우, 기존에 있는 기능은 최소로 수정하고, 확장을 통해 손쉽게 구현할 수 있어야 한다.
- 용어
  - 확장에 열려있다 - 변경 사항이 생겼을 때, 유연하게 코드를 추가함으로써 큰 힘을 들이지 않고 애플리케이션 기능을 확장 할 수 있다.
  - 변경에 닫혀있다 - 새로운 변경 사항이 발생했을때, 객체를 직접적으로 수정하는건 지양함
- 즉, 쉽게 말해 추상화, 인터페이스와 추상 클래스를 활용해 구현하라는 뜻이다.



## 리스코프 치환 원칙 (Liskov Substitution Principle, LSP)

> **자식 클래스는 언제나 부모 클래스를 대체**할 수 있어야 한다는 원칙

- 쉽게 말하자면, 업캐스팅된 부모의 매소드를 사용해도 문제 없이 동작이 되어야 한다는 원칙
- 다형성을 이용하기 위한 원칙
- 예를 들면, 콜렉션을 상속 받아 만들어진 객체들은 뭐를 만들었던 간에 size로 크기를 확인할 수 있는 방식.

```kotlin
fun main() {
    val col: Collection<Int> = listOf(1,2,3)
    printSize(col)
}


fun <T> printSize(col : Collection<T>) {
    println(col.size)
}
```





## 인터페이스 분리 원칙 (Interface Segregation Principle, ISP)

> 인터페이스는 언제나 사용하는 인터페이스만 의존해야한다는 규칙



## 의존 역전 원칙 (Dependency Inversion Principle, DIP)

> 어떤 클래스를 사용하고 싶다면, 그 **클래스를 직접 참조하는게 아니라 상위 요소를 참조**하라는 원칙



# 참고

https://inpa.tistory.com/entry/OOP-💠-객체-지향-설계의-5가지-원칙-SOLID#