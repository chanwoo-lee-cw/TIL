# SOLID μ›μΉ™

κ°μ²΄ μ§€ν–¥ ν”„λ΅κ·Έλλ°(OOP)μ—μ„ κ°€κΈ‰μ μ΄λ©΄ μ§€μΌμ¤μ•Όν–μΌλ©΄ ν•λ” 5κ°€μ§€ μ›μΉ™μ μ•½μ
μ¦‰, μ½”λ“μ ν™•μ¥μ„±κ³Ό μ¬μ‚¬μ©μ„±μ„ λ†’μ΄κ³ , λ³µμ΅λ„λ¥Ό μ¤„μ΄κΈ° μ„ν•΄ μ μ•λ 5κ°€μ§€ μ›μΉ™μ΄λ‹¤.

## λ‹¨μΌ μ±…μ„ μ›μΉ™ (Single Responsibility Principle, SRP)

> **ν•λ‚μ ν΄λμ¤(κ°μ²΄)λ” λ‹¨ ν•λ‚μ μ±…μ„λ§ κ°€μ Έμ•Ό** ν•λ‹¤λ” μ›μΉ™

- ν΄λμ¤λ” μ–Έμ λ‚ ν•λ‚μ κΈ°λ¥μ„ κ°€μ Έμ•Ό ν•κ³ , κ°€κΈ‰μ μ΄λ©΄ κ°μ λ”°λ΅ λ‚λ„λ” κ²ƒμ΄ μΆ‹λ‹¤λ” μ›μΉ™
- μλ¥Ό λ“¤λ©΄, μ£Όλ¬Έμ΄ λ“¤μ–΄μ™”μ„ λ• μ¬κ³ λ¥Ό μ°¨κ°ν•λ” λ¶€λ¶„κ³Ό κµ¬λ§¤μμ—κ² λ©”μΌμ„ λ³΄λ‚΄λ” λ¶€λ¶„μ„ λ¶„λ¦¬ν•λ”κ² λ‚«λ‹¤.
- ν• ν΄λμ¤κ°€ λ‹¤λ¥Έ ν΄λμ¤μ κΈ°λ¥μ„ μ§€μ›ν•λ‹¤λ©΄, λ§μ•½ μ΄ ν΄λμ¤μ— λ¬Έμ κ°€ μƒκΈ°λ©΄ μ΄ κΈ°λ¥μ„ μ‚¬μ©ν•λ” λ‹¤λ¥Έ κΈ°λ¥λ“¤λ„ λ¬Έμ κ°€ μƒκΈ° λ•λ¬Έμ΄κΈ°λ„ ν•κ³ , μ΄ κΈ°λ¥μ΄ μ™ μ΄ ν΄λμ¤μ— μλ”μ§€ ν™•μΈν•κΈ° μ–΄λ ¤μ›μ„ μ μ§€λ³΄μκ°€ μ–΄λ ¤μ›μ§„λ‹¤.



## κ°λ°© νμ‡„ μ›μΉ™ (Open Closed Principle, OCP)

> ν΄λμ¤λ” **ν™•μ¥μ— λ€ν•΄ μ—΄λ ¤ μμ–΄μ•Ό ν•λ©°, μμ •μ—λ” λ‹«ν€**μμ–΄μ•Ό ν•λ‹¤λ” μ›μΉ™

- κΈ°λ¥ μ¶”κ°€κ°€ ν•„μ”ν• κ²½μ°, κΈ°μ΅΄μ— μλ” κΈ°λ¥μ€ μµμ†λ΅ μμ •ν•κ³ , ν™•μ¥μ„ ν†µν•΄ μ†μ‰½κ² κµ¬ν„ν•  μ μμ–΄μ•Ό ν•λ‹¤.
- μ©μ–΄
  - ν™•μ¥μ— μ—΄λ ¤μλ‹¤ - λ³€κ²½ μ‚¬ν•­μ΄ μƒκ²Όμ„ λ•, μ μ—°ν•κ² μ½”λ“λ¥Ό μ¶”κ°€ν•¨μΌλ΅μ¨ ν° νμ„ λ“¤μ΄μ§€ μ•κ³  μ• ν”λ¦¬μΌ€μ΄μ… κΈ°λ¥μ„ ν™•μ¥ ν•  μ μλ‹¤.
  - λ³€κ²½μ— λ‹«ν€μλ‹¤ - μƒλ΅μ΄ λ³€κ²½ μ‚¬ν•­μ΄ λ°μƒν–μ„λ•, κ°μ²΄λ¥Ό μ§μ ‘μ μΌλ΅ μμ •ν•λ”κ±΄ μ§€μ–‘ν•¨
- μ¦‰, μ‰½κ² λ§ν•΄ μ¶”μƒν™”, μΈν„°νμ΄μ¤μ™€ μ¶”μƒ ν΄λμ¤λ¥Ό ν™μ©ν•΄ κµ¬ν„ν•λΌλ” λ»μ΄λ‹¤.



## λ¦¬μ¤μ½”ν”„ μΉν™ μ›μΉ™ (Liskov Substitution Principle, LSP)

> **μμ‹ ν΄λμ¤λ” μ–Έμ λ‚ λ¶€λ¨ ν΄λμ¤λ¥Ό λ€μ²΄**ν•  μ μμ–΄μ•Ό ν•λ‹¤λ” μ›μΉ™

- μ‰½κ² λ§ν•μλ©΄, μ—…μΊμ¤ν…λ λ¶€λ¨μ λ§¤μ†λ“λ¥Ό μ‚¬μ©ν•΄λ„ λ¬Έμ  μ—†μ΄ λ™μ‘μ΄ λμ–΄μ•Ό ν•λ‹¤λ” μ›μΉ™
- λ‹¤ν•μ„±μ„ μ΄μ©ν•κΈ° μ„ν• μ›μΉ™
- μλ¥Ό λ“¤λ©΄, μ½λ ‰μ…μ„ μƒμ† λ°›μ•„ λ§λ“¤μ–΄μ§„ κ°μ²΄λ“¤μ€ λ­λ¥Ό λ§λ“¤μ—λ κ°„μ— sizeλ΅ ν¬κΈ°λ¥Ό ν™•μΈν•  μ μλ” λ°©μ‹.

```kotlin
fun main() {
    val col: Collection<Int> = listOf(1,2,3)
    printSize(col)
}

fun <T> printSize(col : Collection<T>) {
    println(col.size)
}
```

λ§μ•½ μμ™Έ μΌ€μ΄μ¤κ°€ μμ£Ό λ“¤μ–΄μ¤κ² λλ‹¤λ©΄ μ–΄λ–»κ² ν•΄μ•Όν• κΉ?

```kotlin
abstract class Bird {
    abstract fun fly();
    abstract fun eat();
}

class Eagle : Bird() {
    override fun fly() { TODO("Not yet implemented") }

    override fun eat() { TODO("Not yet implemented") }
}


class Swallow : Bird() {
    override fun fly() { TODO("Not yet implemented") }

    override fun eat() { TODO("Not yet implemented") }
}
```

λ¨λ“  μƒλ” λ‚  μ μκ³ , λ¨Ήμ„ μ μμΌλ‹κΉ. Bird λΌλ” μ¶”μƒ ν΄λμ¤ μ•μ— `fly`μ™€ `eat` μ„ λ„£μ—λ‹¤.

ν•μ§€λ§, λ§μ•½ μ—¬κΈ°μ— ν­κ·„κ³Ό νƒ€μ΅°κ°€ λ“¤μ–΄μ¨λ‹¤λ©΄ μ–΄λ–¨κΉ? νƒ€μ΅°μ™€ ν­κ·„μ€ λ‚  μκ°€ μ—†λ‹¤.

ν•μ§€λ§, ν­κ·„κ³Ό νƒ€μ΅°μ κ²½μ°μ— flyλ¥Ό λ“¤μ–΄μ¤κ² λλ‹¤λ©΄ Errorλ¥Ό λ°ν–‰ν•κ² ν–μ„λ•λ” λ‚μ¤‘μ— λ¬Έμ κ°€ μƒκΈΈ μ—¬μ§€κ°€ μλ‹¤.

ν•΄κ²°μ±…

```kotlin
interface Flyable {
    fun fly();
}

abstract class Bird {
    abstract fun eat();
}

class Eagle : Bird(), Flyable {
    override fun fly() { TODO("Not yet implemented") }

    override fun eat() { TODO("Not yet implemented") }
}


class Swallow : Bird(), Flyable {
    override fun fly() { TODO("Not yet implemented") }

    override fun eat() { TODO("Not yet implemented") }
}

class Penguin : Bird() {
    override fun eat() { TODO("Not yet implemented") }
}


class Ostrich : Bird() {
    override fun eat() { TODO("Not yet implemented") }
}
```

λ°‘μ—μ„ μ–ΈκΈ‰ν•  **ISP**λ„ μ§€ν‚¤κ² λκ³ , λ‚  μ μ—†λ” μƒλ“¤λ„ λ¬Έμ  μ—†μ΄ Bird λ΅ μ·¨κΈ‰ν•  μ μκ² λλ‹¤.



## μΈν„°νμ΄μ¤ λ¶„λ¦¬ μ›μΉ™ (Interface Segregation Principle, ISP)

> μΈν„°νμ΄μ¤λ” μ–Έμ λ‚ μ‚¬μ©ν•λ” μΈν„°νμ΄μ¤λ§ μμ΅΄ν•΄μ•Όν•λ‹¤λ” κ·μΉ™

- ν° μΈν„°νμ΄μ¤ ν•λ‚λ³΄λ‹¤λ”, **μ‘κ³  κµ¬μ²΄μ μΈ μΈν„°νμ΄μ¤ μ—¬λ¬ κ°**λ΅ λ‚λ„λ” κ²ƒμ΄ μΆ‹λ‹¤.
- μ¦‰, μΈν„°νμ΄μ¤λ” κ°κ° μ©λ„μ— λ§κ² μκ² λ¶„λ¦¬ν•΄μ•Όν•λ‹¤λ” μ„¤κ³„ μ›μΉ™μ΄λ‹¤.
- SRPκ°€ ν΄λμ¤μ λ‹¨μΌ μ±…μ„μ„ λ§λ‹¤λ©΄, **ISPλ” μΈν„°νμ΄μ¤μ λ‹¨μΌ μ±…μ„μ„ κ°•μ΅°**.
  - μΈν„°νμ΄μ¤λ¥Ό μ‚¬μ©ν•λ” ν΄λΌμ΄μ–ΈνΈλ¥Ό κΈ°μ¤€μΌλ΅ λ¶„λ¦¬ν•¨μΌλ΅μ¨, **ν΄λΌμ΄μ–ΈνΈμ λ©μ κ³Ό μ©λ„μ— μ ν•©ν• μΈν„°νμ΄μ¤ λ§μ„ μ κ³µ**ν•λ” κ²ƒμ΄ λ©ν‘.
- μ”μ»¨λ°, **μ‚¬μ©ν•μ§€ μ•λ” κΈ°λ¥μ΄ λ§μ€ μΈν„°νμ΄μ¤λ” λ‚μ μ„¤κ³„**
- μ£Όμν•  μ μΌλ΅λ” **μΈν„°νμ΄μ¤λ” κ°€κΈ‰μ μ΄λ©΄ ν•λ² κµ¬μ„±ν•΄ λ†“κ³  λ°”κΎΈμ§€ μ•λ” κ²ƒμ΄ μ΄μƒμ **μ΄λ‹¤. λ‹¤λ§, κΌ­ κ·Έλ°κ±΄ μ•„λ‹λ‹¤. ν•„μ”ν•λ‹¤ μ‹¶μΌλ©΄ λ¶„λ¦¬ν•λ”κ² μ •μ„
  - μ΄ μΈν„°νμ΄μ¤λ¥Ό κµ¬ν„ν•λ” ν΄λμ¤λ“¤λ§λ‹¤ **κµ¬ν„ν•μ§€ μ•λ” κΈ°λ¥μ΄ λμ–΄λ‚κ³ ** μλ‹¤λ©΄ β†’ λ¶„λ¦¬ μ‹μ .
  - ν•λ‚μ μΈν„°νμ΄μ¤κ°€ **μ—¬λ¬ μ±…μ„(Roles)μ„ κ°€μ§€λ” κ²ƒμ²λΌ λ³΄μΈλ‹¤λ©΄** β†’ λ¶„λ¦¬ μ‹μ .
  - ν΄λΌμ΄μ–ΈνΈ μ½”λ“κ°€ **ν•„μ” μ—†λ” κΈ°λ¥μ„ λ³΄κ² λλ” μκ°„** β†’ λ¶„λ¦¬ μ‹μ .



## μμ΅΄ μ—­μ „ μ›μΉ™ (Dependency Inversion Principle, DIP)

> μ–΄λ–¤ ν΄λμ¤λ¥Ό μ‚¬μ©ν•κ³  μ‹¶λ‹¤λ©΄, κ·Έ **ν΄λμ¤λ¥Ό μ§μ ‘ μ°Έμ΅°ν•λ”κ² μ•„λ‹λΌ μƒμ„ μ”μ†λ¥Ό μ°Έμ΅°**ν•λΌλ” μ›μΉ™

- κµ¬ν„ ν΄λμ¤λ¥Ό μ§μ ‘ μ°Έμ΅°ν•λ”κ±Έ λΉ„μ¶”μ²ν•κ³ , ν•΄λ‹Ή μΈν„°νμ΄μ¤λ‚ μ¶”μƒ ν΄λμ¤λ¥Ό μ°Έμ΅°λΌν•λ” λ»μ΄λ‹¤.
- μ¦‰, κµ¬ν„λ³΄λ‹¤λ” μ¶”μƒν™”(μΈν„°νμ΄μ¤, μ¶”μƒ ν΄λμ¤)μ— μμ΅΄ν•λΌλ” λ»
  - μ½”λ“μ μ¤‘μ”ν• ν•µμ‹¬ λ¶€λ¶„μ€ λ°”λ€μ§€ μ•μ•„μ•Όν•λ‹¤.
  - λ³€ν™”κ°€ μμ£Ό μΌμ–΄λ‚λ” μ½”λ“μ—μ„μ μμ΅΄ κ΄€κ³„λ¥Ό μ—†μ•¤λ‹¤. -> μ¦‰, μμ£Ό λ³€κ²½λλ”κ°€λ¥Ό λ”°μ Έμ„ μ¶”μƒν™”λ¥Ό μ‹μΌμ•Όν•λ‹¤.



# μ°Έκ³ 

https://inpa.tistory.com/entry/OOP-π’ -κ°μ²΄-μ§€ν–¥-μ„¤κ³„μ-5κ°€μ§€-μ›μΉ™-SOLID#

https://yoojin99.github.io/cs/Dependency-Inversion-Principle/